% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_multisample.R, R/mutlisample_init.R
\name{multisample_init}
\alias{multisample_init}
\title{Create multisample segmentation}
\usage{
multisample_init(cnaqc_objs)

multisample_init(cnaqc_objs)
}
\arguments{
\item{cnaqc_objs}{named list of CNAqc objects, one per sample (each element must include at 
least "mutations", "cna", "reference" and "purity"). Names of the list must correspond to sample_id}

\item{cna_type}{can be "clonal", "subclonal" or both. Specifies which mutations must be considered in the creation of the 
m_CNAqc object. At the moment, the function is implemented for clonal mutations only. Default = "clonal"}

\item{QC_filter}{logical. Indicates wheter to filter or not for QC-passing mutations}
}
\value{
a multi_CNAqc object. Every element of the object correspond to one of the sample, structured as follows: 
- `shared_mutations` = CNAqc object for the considered sample, containing all the information (mutations, cna, purity, etc) for
   mutations mapped on segments shared across all the samples;
- `private_mutations` = table including all the mutations, mapped on new segments that are not shared across all samples;
- `original_additional_info` = additional information (i.e.: CCF, peaks analysis, etc) from the original CNAqc object stored as a list (refers to the
   original segmentation!).

A list of four elements: 
- `joint_segments` = table with the join segmentation. output of the join_segments function
- `joint_table` = table with mutations mapped on the new common segments 
- `metadata` = a tibble including additional information for each sample, such as reference genome and purity
- `original_data` = a list in which each element is the original CNAqc object for every sample
}
\description{
Creates a m_CNAqc object starting from a named list of CNAqc objects on which the quality control has already been 
performed individually (ie: multiple samples coming from the same patient). Breakpoints from the original CNAqc objects are
used to define new breakpoints (and then segments) common across all the samples; in the resulting object, the mutations are 
remapped on the newly defined segments. 
The new m_CNAqc object can be used to perform new a quality control analysis with the different segmentation.

In order to obtain a "joint table" including all the different samples of the same patient the
existing CNAqc objects (one per sample) must be merged, obtaining a new multi-sample CNAqc object
(mCNAqc) which includes all the information about the mutations and a new common segmentation
between all samples.
}
\examples{
# get better dataset! --> still to check



CNAqc_samples = lapply(names(sample_mutations), function(x) {
  CNAqc::init(mutations = sample_mutations[[x]], 
           cna = cna[[x]], 
           purity = purity[[x]], 
           sample = x,
           ref = "GRCh38")
  })

names(CNAqc_samples) = sapply(CNAqc_samples, function(x) {x$sample})

# perform peak analysis

CNAqc_samples = lapply(CNAqc_samples, function(x) {
  
  CNAqc::analyze_peaks(x, matching_strategy = 'closest')
  
})

create the multi_CNAqc object

multisamples = CNAqc::multisample_init(cnaqc_objs = CNAqc_samples)

multisamples




# get better dataset!
x1 = init(
  mutations = example_dataset_CNAqc$mutations \%>\%  sample_n(1000),
  cna = example_dataset_CNAqc$cna \%>\% sample_n(100),
  purity = example_dataset_CNAqc$purity,
  sample = "xxx",
  ref = example_dataset_CNAqc$reference,
)
x2 = init(
  mutations = example_dataset_CNAqc$mutations \%>\%  sample_n(1000),
  cna = example_dataset_CNAqc$cna \%>\% sample_n(100),
  purity = example_dataset_CNAqc$purity,
  sample = "yyy",
  ref = example_dataset_CNAqc$reference,
)

cnaqc_objs = list(x1,x2)
names(cnaqc_objs) = c("s1", "s2")

mCNAqc = multisample_init(cnaqc_objs = cnaqc_objs)

}
