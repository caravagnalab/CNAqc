---
title: "10. multiCNAqc"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{10. multiCNAqc object}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, 
  comment = "#>"
)

# options(crayon.enabled=F)

VCF_url = "https://raw.githubusercontent.com/caravagnalab/CNAqc_datasets/main/MSeq_Set06/Mutations/Set.06.WGS.merged_filtered.vcf"

# Download, load and cancel data
download.file(VCF_url, "Set.06.WGS.merged_filtered.vcf",)

set6 = vcfR::read.vcfR("Set.06.WGS.merged_filtered.vcf")
file.remove("Set.06.WGS.merged_filtered.vcf")

require(CNAqc)
require(tidyverse)

# INFO fields 
info_tidy = vcfR::extract_info_tidy(set6)

# Fixed fields (genomic coordinates)
fix_tidy = set6@fix %>%
  as_tibble %>%
  rename(
    chr = CHROM,
    from = POS,
    ref = REF,
    alt = ALT
  ) %>%
  mutate(from = as.numeric(from), to = from + nchar(alt))

# Genotypes
geno_tidy = vcfR::extract_gt_tidy(set6) %>%
  group_split(Indiv)

# Sample mutations in the CNAqc format
sample_mutations = lapply(geno_tidy, function(x) {
  bind_cols(info_tidy, fix_tidy) %>% 
    full_join(x, by = "Key") %>%
    filter(FILTER == "PASS") %>% 
    mutate(DP = as.numeric(gt_NR), NV = as.numeric(gt_NV)) %>%
    mutate(VAF = NV / DP) %>%
    dplyr::select(chr, from, to, ref, alt, NV, DP, VAF, everything()) %>%
    filter(!is.na(VAF), VAF > 0)
})

# A list for all samples available
names(sample_mutations) = sapply(sample_mutations, function(x) x$Indiv[1])
sample_mutations = sample_mutations[!is.na(names(sample_mutations))]
sample_mutations = sample_mutations[1:3]

# Load Sequenza output
load_SQ_output = function(URL, sample, run)
{
  # We can directly read them from remote URLs
  segments_file = paste0(URL, run, '/', sample, '.smoothedSegs.txt')
  purity_file = paste0(URL, run, '/', sample, '_confints_CP.txt')
  
  # Get segments
  segments = readr::read_tsv(segments_file, col_types = readr::cols()) %>%
    dplyr::rename(
      chr = chromosome,
      from = start.pos,
      to = end.pos,
      Major = A,
      minor = B
    ) %>%
    dplyr::select(chr, from, to, Major, minor, dplyr::everything())
  
  # Get purity and ploidy
  solutions = readr::read_tsv(purity_file, col_types = readr::cols())
  
  purity = solutions$cellularity[2]
  ploidy = solutions$ploidy.estimate[2]
  
  return(
    list(
      segments = segments,
      purity = purity,
      ploidy = ploidy
    )
  )
}

Sequenza_URL = "https://raw.githubusercontent.com/caravagnalab/CNAqc_datasets/main/MSeq_Set06/Copy%20Number/"

# Final sequenza run (good calls)
Sequenza_good_calls = lapply(names(sample_mutations), function(x) {
  load_SQ_output(Sequenza_URL, sample = x, run = 'final')
})[1:3]

names(Sequenza_good_calls) = names(sample_mutations)

# CNA segments and purity
cna = lapply(Sequenza_good_calls, function(x) {x$segments})
purity = lapply(Sequenza_good_calls, function(x) {x$purity})

```

```{r setup, warning = T}
require(devtools)
require(tidyverse)
devtools::load_all()
require(cli)
```

# Create a multisample CNAqc object

If treating data belonging to the same patient, but from different samples (ie: longitudinal or multi-region sampling), it might be handful searching for genomic regions harboring abnormal copy number states in all of the samples.

## Analysis setup

For this example we will use the same data presented in the [example data analysis](https://caravagnalab.github.io/CNAqc/articles/a7_example_MSeq.html) in order to create a multisample CNAqc object for the patient `Set06` (samples 1-3 of the same patient).

After having extracted the information on mutations and CNA for each sample, we create a list of CNAqc objects. List names must be sample names.

```{r, message=FALSE}
CNAqc_samples = lapply(names(sample_mutations), function(x) {
  CNAqc::init(mutations = sample_mutations[[x]], 
              cna = cna[[x]], 
              purity = purity[[x]], 
              sample = x,
              ref = "GRCh38")
})

names(CNAqc_samples) = sapply(CNAqc_samples, function(x) {x$sample})
```

Run the quality control on the created object.

```{r, include=FALSE}
CNAqc_samples = lapply(CNAqc_samples, function(x) {
  CNAqc::analyze_peaks(x, matching_strategy = 'closest', min_VAF = 0)
})
```

## Create the mCNAqc object

Create a `m_CNAqc` object using the all the CNAs included in the objects. This will define new segments according to which genomic regions are affected by CNAs in all samples, and remap the mutations on them.

All breakpoints (`from` and `to` of each CNA table) from all samples are selected and reordered. The list is then used to generate new segments intervals as shown in the picture; only segments that are present in all samples will be kept. Mutations are then remapped on the new segments.

```{r echo=FALSE, fig.align = "center", fig.cap = "Example of common segmentation, considering three samples (A, B and C) from the same patient (original segments are represented as the red, blue and yellow orizontal lines). New segments are defined by considering the edges of all original segments (dashed vertical lines), and searching for regions that are known to show different copy number state in all the samples (regions highlighted in green).", fig.width=800}
knitr::include_graphics("images/joint_segmentation.png")
```

<!-- ![](images/joint_segmentation.png){width="600"} -->

**Important**: Mutations that are not mapped on segments shared across samples will be lost in the final object, while mutations that are mapped on shared segments are stored in a CNAqc object under the `mutations_on_shared` attribute of the result.

```{r}
example_multisample = CNAqc::multisample_init(cnaqc_objs = CNAqc_samples, 
                                              QC_filter = TRUE,
                                              keep_original = TRUE)

print(example_multisample)
```

It is possible to use S3 method `plot` in order to visualize the result.

```{r}
# TBD plot method
```

## Getters

To access all the mutations falling on the new shared segments for desired samples use the getter `shared_segments_mutations`, which returns a tibble with mutations on common segments across samples.

```{r}
shared_segments_mutations(example_multisample, 
                                 sample = "all",
                                 type = c("SNV", "indel"))
```

Mutations from the original CNAqc objects can be retrieved by using `original_segments_mutations` (returns a tibble).

```{r}
original_segments_mutations(example_multisample, 
                            sample = "all", 
                            type = c("SNV", "indel"))
```

Original CNAqc objects of all samples can be saved if setting the argument `keep_original = TRUE`. They can be accessed by using the getter `original`.

```{r}
original(example_multisample, 
                sample = "all")
```

CNAqc objects with the new segmentations can be accessed by using the getter `new_segments_CNAqc`.

```{r}
new_segments_CNAqc(example_multisample)
```
