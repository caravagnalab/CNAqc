---
title: "9. Automatic CNA calling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{9. Automatic CNA calling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

options(crayon.enabled=FALSE)
```

Sequenza (Favero et al., 2015) calls clonal CNAs in a multi-steps Python/R pipeline:

first it process a FASTA file to produce a GC Wiggle track file; 
then process tumour and normal BAMs and Wiggle files to produce a seqz file;
then bins the original seqz file; 
binned seqz data are then processed for normalisation and segmentation;
a grid-search approach is used to estimate cellularity and ploidy;
results are dumped for both the best and possible alternative solutions.

Here cellularity is the Sequenza terminology for tumour purity. Note that steps 1-3 are implemented in Python, while steps 4-6 in R. In our experience, we have often found the first three steps to be repeated just once and often with default parameter values, while the last steps are usually run more often to optimise CNA calling.

For this reason, we have implemented a CNA calling pipeline in CNAqc (R function “Sequenza_CNAqc”) that revolves around steps 4-6, using CNAqc to drive the fitting steps of Sequenza - especially step 5 - to determine better CNA segments and purity/ploidy values. The pipeline starts from input ranges for cellularity and ploidy values, as canonically required by Sequenza. Parameters for segmentation are also imputed following the standard Sequenza convention, and step 4 is performed once before starting an iterative procedure that uses a caching system to avoid useless repetitions of computations.

The pipeline fits (Sequenza steps 5-6) cellularity and ploidy values, and dumps results, which are quality controlled by peak detection via CNAqc. The analysis with CNAqc can be carried out using either somatic mutations called by Sequenza, or an external set of input calls. Besides the best solution by Sequenza, at every run up to two alternative solutions are generated:

One optional by Sequenza, which might propose new exact values for cellularity and ploidy (that differ from the current best ones);
One by CNAqc, adjusting the current cellularity of the best Sequenza solution, leaving the ploidy unchanged (as per the scores of CNAqc).

These alternative solutions are enqueued in a list L of cellularity and ploidy values that should be tested, based on their presence in the cache. Until the list L is empty, the point values of cellularity and ploidy are tested repeating steps 5-6 using ranges around the proposed values - i.e., if a solution with cellularity 34% and ploidy 2.5 should be tested, Sequenza is run by using ranges 34%c and 2.5p, where c and pare parameters of the pipeline. 

Therefore the pipeline follows the gradient of correction suggested by CNAqc, as well as Sequenza’s alternative solutions. Note that when CNAqc flags as PASS a solution that is visited for the first time, any further correction will not be evaluated since the solution will be found in the cache system of the pipeline. At the end of the runs all the solutions identified are scored by CNAqc and reported with a PASS/FAIL status associated; the pipeline always indicates the best among the tested ones, based on the assigned quality score.


